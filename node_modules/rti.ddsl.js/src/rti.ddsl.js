/*****************************************************************
 * (c) Copyright, Real-Time Innovations
 * All rights reserved.
 * No duplications, whole or partial, manual or electronic, may be made
 * without express written permission.  Any such copies, or
 * revisions thereof, must display this notice unaltered.
 * This code contains trade secrets of Real-Time Innovations, Inc.
 *
 *     modification history
 *     ---------------------
 *
 *
 */

var exports = module.exports = {};


// ****************************************************************************
// Utilities
// ****************************************************************************
// Add the method 'repeat' to the global String class, to simply return the
// concatenation of that string for n-times.
// Implementation is just sick... creates an array with n+1 elements that are initially
// undefined. Then use the join method to join them together, using the original string as
// separator: you get n-times the separator concatenated...
String.prototype.repeat = function(n) {
    return n ? new Array(n+1).join(this) : ""
}

// Defines a global function in the Javascript VM namespace that can be invoked
// from LUA to the content of a file. Apparently the 'require' function is not
// globally visible from the js.global table.
RTIDDSLReadFile = function(fileName) {
    return require("fs").readFileSync(fileName, "utf8");
}

// ****************************************************************************
// RTIDDSL Class
// ****************************************************************************
// Builds a new RTIDDSL object
//
// Requires the module lua.vm.js (use 'npm i lua.vm.js' to install)
//
// \param useConsole    Boolean set to true to cause the methods to print messages
//                      on the JS console. Set it to false to be quiet.
//                      Optional param. Default=false
exports.RTIDDSL = function(useConsole, L) {
    // Private properties
    var _theLuaVM;
    if (L != null) {
        _theLuaVM = L;
    } else {
        var luavm = require('lua.vm.js');
        _theLuaVM = new luavm.Lua.State();
    }
    var _theUseConsole = useConsole || false;
    var _theVmInit = false;         // Allow to load LUA VM only once
    var _theDefaultLuaPath = __dirname + "/../../../src";


    // Constants - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    // For consistency the following constants are initialized from the LUA DDSL
    var KIND_ANNOTATION;
    var KIND_ATOM;
    var KIND_ENUM;
    var KIND_STRUCT;
    var KIND_UNION;
    var KIND_TYPEDEF;
    var KIND_CONST;
    var KIND_MODULE;

    // The right name is kind of tricky to get at run-time from DDSL...
    this.ANNOTATION_KIND_SEQUENCE      = "sequence";
    this.ANNOTATION_KIND_ARRAY         = "array";;
    this.ANNOTATION_KIND_ID            = "ID"
    this.ANNOTATION_KIND_OPTIONAL      = "Optional";
    this.ANNOTATION_KIND_MUSTUNDERSTAND  = "MustUnderstand";
    this.ANNOTATION_KIND_SHARED        = "Shared";
    this.ANNOTATION_KIND_BITBOUND      = "BitBound";
    this.ANNOTATION_KIND_BITSET        = "BitSet";
    this.ANNOTATION_KIND_EXTENSIBILITY = "Extensibility";
    this.ANNOTATION_KIND_NESTED        = "Nested";
    this.ANNOTATION_KIND_TOPLEVEL      = "top_level";

    // Privileged & Public Methods - - - - - - - - - - - - - - - - - - - - - -
    // {{{ executeLua
    // ----------------------------------------------------------------------------
    // Executes the given LUA code on the current LUA VM instance.
    //
    // \param L     the instance of the LUA VM
    // \param code  the LUA code to execute
    // \return      the result of the execution of the LUA code encapsulated in an array.
    //              If the LUA result is a single value, the array contains one element.
    // \throw       An exception if an error occurred while executing the LUA code
    this.executeLua = function(code) {
      try {
        return _theLuaVM.execute(code);
      } catch(e) {
        console.error("Error executing LUA code: " + e);
        console.error("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
        console.error(code);
        _theLuaVM.printStack();
        console.error("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
        throw e;
      }
    }
    // }}}
    // {{{ logMessage
    // ----------------------------------------------------------------------------
    // Optionally logs a message on the JS console
    this.logMessage = function(msg) {
        if (_theUseConsole) {
            console.log(msg);
        }
    }
    // }}}
    // {{{ loadDDSL
    // ----------------------------------------------------------------------------
    // Loads the DDSL into the LUA VM
    //
    // \param ddslDir   the string containing the path to DDSL
    this.loadDDSL = function(ddslDir) {
        ddslDir = ddslDir || _theDefaultLuaPath;
        this.logMessage("DDSL: Loading DDSL from path '" + ddslDir + "'...");
        if (this._theVmInit) {
            this.logMessage("VM already initialized");
            return;
        }

        var fs = require('fs');

        // List all the modules being referenced (event through nested require() calls)
        //   req: put here exactly what you type in the require() function
        //   fn : the file name where this module/file will be mapped.
        var allFiles = [
            { req:"logger",                                     fn:"logger.lua" },
            { req:"ddsl",                                       fn:"ddsl/init.lua" },
            { req:"ddsl.version",                               fn:"ddsl/version.lua" },
            { req:"ddsl.xtypes",                                fn:"ddsl/xtypes/init.lua" },
            { req:"ddsl.xtypes.xml",                            fn:"ddsl/xtypes/xml/init.lua" },
            { req:"ddsl.xtypes.xml.parser",                     fn:"ddsl/xtypes/xml/parser.lua" },
            { req:"ddsl.xtypes.utils",                          fn:"ddsl/xtypes/utils/init.lua" },
            { req:"ddsl.xtypes.utils.nslookup",                 fn:"ddsl/xtypes/utils/nslookup.lua" },
            { req:"ddsl.xtypes.utils.to_idl_string_table",      fn:"ddsl/xtypes/utils/to_idl_string_table.lua" },
            { req:"ddsl.xtypes.utils.to_instance_string_table", fn:"ddsl/xtypes/utils/to_instance_string_table.lua" }
        ];

        this.logMessage("Initializing LUA VM...");

        // Re-define the LUA function require() to... essentially instead of load the file
        // call a local function that will be defined later.
        // The function name is composed by:
        //      'single_' + <module name>
        //
        // NOTE: Since the module name contains dots (and dots are bad because they
        // means 'table lookup', we need to replace all those dots into underscores
        // (that's why we do a string.gsub...)
        this.executeLua(" \
                local oldrequire = require \
                __rtiLoadedModules = {} \
                function newrequire(name) \
                    fnName = 'single_' .. string.gsub(name, '%.', '_') \
                    if not __rtiLoadedModules[name] then \
                        if _G[fnName] then \
                            __rtiLoadedModules[name] = _G[fnName]() \
                        else \
                            print('!!Error: required module \"'..name..'\" is not defined') \
                        end \
                    end \
                    return __rtiLoadedModules[name] \
                end \
                require = newrequire");

        // Here iterates through all the known files and define functions that as body
        // contains the whole file content.
        for (var i=0; i < allFiles.length; ++i) {
            var ff = fs.readFileSync(ddslDir + "/" +  allFiles[i].fn, "utf8");
            // Same as LUA those functions need to have the dots replaced with _.
            // This time we do this pattern match replace in Javascript...
            var fnName = "single_" + allFiles[i].req.replace(/\./g, "_");
            this.executeLua(fnName + " = function() " + ff + " end ");
        }

        // Finally Load ddsl
        this.executeLua(" \
                xtypes = require('ddsl.xtypes') \
                xml = require('ddsl.xtypes.xml') \
                xutils = require('ddsl.xtypes.utils') \
                ");                              
        this.logMessage("LUA VM successfully loaded");

        // Define a function that takes a table and always return the unique pointer
        // LUA doesn't have a global rawstring(), so if the object is a table and this
        // table have a metatable, it will always try to call __tostring.
        // Trick here is to check if is a table, temporarily remove the metatable,
        // then call tostring() on the table (that will default on the system' default
        // tostring()) then restore the original metatable.
        //
        // Returns nil if argument is not a table
        this.executeLua(" \
                function rawstring(N) \
                    local retVal = nil \
                    if (type(N) == type({})) then \
                        local mt = getmetatable(N) \
                        setmetatable(N, nil) \
                        retVal = tostring(N) \
                        setmetatable(N, mt) \
                    end \
                    return retVal \
                    end");

        // Defines a lookup table that is used to store all the LUA objects used during
        // the tree navigation. Objects are indexed by their raw string representation.
        this.executeLua(" \
                __rtiLookupTree = {} \
                __rtiLookupTreeSize = 0 \
                __rtiLookupTree.addNode = function(item) \
                    if (type(item) == type({})) then \
                        itemKey = rawstring(item) \
                        if (__rtiLookupTree[itemKey] == nil) then \
                            __rtiLookupTree[itemKey] = item \
                            __rtiLookupTreeSize = __rtiLookupTreeSize + 1 \
                        end \
                        return itemKey \
                    end \
                    return item \
                end");

        // Finally initialize the kind constants from the constants defined in DDSL
        this.KIND_ANNOTATION = this.executeLua("return xtypes.ANNOTATION()")[0];
        this.KIND_ATOM = this.executeLua("return xtypes.ATOM()")[0];
        this.KIND_ENUM = this.executeLua("return xtypes.ENUM()")[0];
        this.KIND_STRUCT = this.executeLua("return xtypes.STRUCT()")[0];
        this.KIND_UNION = this.executeLua("return xtypes.UNION()")[0];
        this.KIND_TYPEDEF = this.executeLua("return xtypes.TYPEDEF()")[0];
        this.KIND_CONST = this.executeLua("return xtypes.CONST()")[0];
        this.KIND_MODULE = this.executeLua("return xtypes.MODULE()")[0];
        this._theVmInit = true;

        // Load any additional file (not related to DDSL)
        /*
        var dumpvarLua = require('fs').readFileSync(__dirname + "/dumpvar.lua", "utf8");
        this.executeLua(dumpvarLua);
        this.logMessage("Successfully loaded utility 'dumpvar'");
        */

        // Re-define the io.open to handle files using node's fs 
        // Function returns a LUA object that simulates the File object. It has the following methods:
        //  - read: returns the content of the file
        //  - close: removes the content of the file
        this.executeLua(" \
                __rtiDefaultSearchPath = nil \
                io.open = function(filename, mode) \
                    if (mode ~= 'r') then \
                        print('Error: non-read mode not supported in io.open wrapper') \
                        return nil \
                    end \
                    local myFile = {} \
                    myFile.read = function() \
                        return myFile.data \
                    end \
                    myFile.close = function() \
                        myFile.data = nil \
                    end \
                    if (string.sub(filename, 1, 1) ~= '/' and __rtiDefaultSearchPath ~= nil) then \
                        filename = __rtiDefaultSearchPath .. '/' .. filename \
                    end \
                    myFile.data = js.global:RTIDDSLReadFile(filename) \
                    return myFile \
                end");

        // Defines a set of wrapping functions in LUA around the navigation functionality
        this.executeLua(" \
                lua_getArrayCount = function(x) return #__rtiLookupTree[x]; end \
                lua_getArrayItem = function(x, y) return __rtiLookupTree.addNode(__rtiLookupTree[x][y]) end \
                lua_getKind = function(x) local temp = __rtiLookupTree[x][xtypes.KIND]; if type(temp)=='function' then return temp() else return nil; end; end \
                lua_getName = function(x) return __rtiLookupTree[x][xtypes.NAME] end \
                lua_toString = function(x) return tostring(__rtiLookupTree[x]) end \
                lua_getEnclosingScope = function(x) return __rtiLookupTree[x][xtypes.NS] end \
                lua_getSwitch = function(x) return __rtiLookupTree.addNode(__rtiLookupTree[x][xtypes.SWITCH]) end \
                lua_getBase = function(x) return __rtiLookupTree.addNode(__rtiLookupTree[x][xtypes.BASE]) end \
                lua_getNsName = function(x) return xtypes.nsname(__rtiLookupTree[x]) end \
                lua_getNsRoot = function(x) return xtypes.nsroot(__rtiLookupTree[x]) end \
                lua_resolveTypedef = function(x) return __rtiLookupTree.addNode(xtypes.resolve(__rtiLookupTree[x])) end \
                lua_getNext = function(x) local k,v=next(__rtiLookupTree[x]); return k,__rtiLookupTree.addNode(v); end \
        ");

    }

    // }}}
    // {{{ setDefaultSearchPath
    // ----------------------------------------------------------------------------
    // Set or clear default search path. If set the LUA's io.open will prepend this
    // path to the file to load if a full path is not specified.
    this.setDefaultSearchPath = function(path) {
        if (path) {
            this.logMessage("Setting default search path: " + path);
            this.executeLua("__rtiDefaultSearchPath = '" + path + "'");
        } else {
            this.logMessage("Clearing default search path");
            this.executeLua("__rtiDefaultSearchPath = nil");
        }
    }
    // }}}

    // {{{ buildFromFile
    // ----------------------------------------------------------------------------
    this.buildFromFile = function(fileName) {
        this.logMessage("Loading from file: '" + fileName + "'...");

        // This version loads the file in LUA using js.global
        // return this.executeLua("return __rtiLookupTree.addNode(xml.string2xtypes(js.global:require('fs'):readFileSync('" + fileName + "', 'utf8')))")[0];

        // This version invokes the DDSL xml.file2xtypes that is re-defined in loadDDSL to use
        // node's filesystem
        return this.executeLua("return __rtiLookupTree.addNode(xml.file2xtypes('" + fileName + "'))")[0];

        // This version loads the file in Javascript then pass it to LUA for parsing
        /*
        var fs = require('fs');
        this.logMessage("Loading XML '" + fileName + "' into LUA VM...");
        var xmlFileContent = fs.readFileSync(fileName, "utf8");
        this.executeLua("xmlStringG = [==[" + xmlFileContent + "]==]");
        return this.executeLua("return __rtiLookupTree.addNode(xml.string2xtypes(xmlStringG))")[0];
        */
       
    }
    // }}}
    // {{{ buildFromString
    // ----------------------------------------------------------------------------
    this.buildFromString = function(body) {
        this.logMessage("Loading from string...");
        this.executeLua("xmlStringG = [==[" + body + "]==]");
        return this.executeLua("return __rtiLookupTree.addNode(xml.string2xtypes(xmlStringG))")[0];
    }
    // }}}

    // {{{ callLuaFunction
    // ----------------------------------------------------------------------------
    // Takes at least 1 argument (the function name)
    var callLuaFunction = function() {
        _theLuaVM.getglobal(arguments[0]);
        for (var i = 1; i < arguments.length; ++i) {
            _theLuaVM.push(arguments[i]);
        }
        _theLuaVM.pcall(arguments.length-1, 1);
        var retVal = _theLuaVM.lua_to_js(1);
        _theLuaVM.pop(1);
        return retVal;
    }
    // }}}

    // DDSL Node Navigation API  - - - - - - - - - - - - - - - - - - - - - - -
    // All the following functions have an equivalent in LUA that starts with lua_
    // The LUA version of those functions are defined in loadDDSL
    // {{{ getArrayCount
    // ----------------------------------------------------------------------------
    // Always returns a Number with the size of the given array
    this.getArrayCount = function(nodeKey) {
        return callLuaFunction("lua_getArrayCount", nodeKey);
    }
    // }}}
    // {{{ getArrayItem
    // ----------------------------------------------------------------------------
    this.getArrayItem = function(nodeKey, idx) {
        return callLuaFunction("lua_getArrayItem", nodeKey, idx);
    }
    // }}}
    // {{{ getKind
    // ----------------------------------------------------------------------------
    // Returns a string version of theh node kind
    this.getKind = function(nodeKey) {
        return callLuaFunction("lua_getKind", nodeKey);
    }
    // }}}
    // {{{ getName
    // ----------------------------------------------------------------------------
    this.getName = function(nodeKey) {
        return callLuaFunction("lua_getName", nodeKey);
    }
    // }}}
    // {{{ toString
    // ----------------------------------------------------------------------------
    this.toString = function(nodeKey) {
        return callLuaFunction("lua_toString", nodeKey);
    }
    // }}}
    // {{{ getEnclosingScope
    // ----------------------------------------------------------------------------
    this.getEnclosingScope = function(nodeKey) {
        return callLuaFunction("lua_getEnclosingScope", nodeKey);
    }
    // }}}
    // {{{ getSwitch
    // ----------------------------------------------------------------------------
    this.getSwitch = function(nodeKey) {
        return callLuaFunction("lua_getSwitch", nodeKey);
    }
    // }}}
    // {{{ getBase
    // ----------------------------------------------------------------------------
    // Given a node returns the base structure, or nil if the struct node doesn't have
    // a parent.
    this.getBase = function(nodeKey) {
        return callLuaFunction("lua_getBase", nodeKey);
    }
    // }}}

    // {{{ getNsName
    // ----------------------------------------------------------------------------
    // Returns the fully qualified namespace
    this.getNsName = function(nodeKey) {
        return callLuaFunction("lua_getNsName", nodeKey);
    }
    // }}}
    // {{{ getNsRoot
    // ----------------------------------------------------------------------------
    this.getNsRoot = function(nodeKey) {
        return callLuaFunction("lua_getNsRoot", nodeKey);
    }
    // }}}
    // {{{ resolveTypedef
    // ----------------------------------------------------------------------------
    this.resolveTypedef = function(nodeKey) {
        return callLuaFunction("lua_resolveTypedef", nodeKey);
    }
    // }}}

    // Generic getNext - Do not assume anything about the returned object
    // {{{ getNext
    // ----------------------------------------------------------------------------
    // Returns an array of two elements: key and value
    this.getNext = function(nodeKey) {
        _theLuaVM.getglobal("lua_getNext");
        _theLuaVM.push(nodeKey);
        _theLuaVM.pcall(1, 2);
        var retVal1 = _theLuaVM.lua_to_js(1);
        var retVal2 = _theLuaVM.lua_to_js(2);
        _theLuaVM.pop(2);
        return [retVal1, retVal2];
    }
    // }}}

    // Miscellaneous
    // {{{ getConstValue
    // ----------------------------------------------------------------------------
    // Returns an array with two elements:
    // 0: the value of the const
    // 1: the type of the const
    this.getConstValue = function(nodeKey) {
        // Invoking the node returns a pair: <value>, <type>
        return this.executeLua("local v,t=__rtiLookupTree['" + nodeKey + "']() \
                              return v, __rtiLookupTree.addNode(t)");
    }
    // }}}
    // {{{ getUnionCase
    // ----------------------------------------------------------------------------
    // Given a node identifying the intermediate node of a case in an union, returns
    // a Javascript array of 3 elements:
    //      0: The case value (either a number of 'NULL' if default)
    //      1: The name of the property (string)
    //      2: The DDSL node of the definition
    this.getUnionCase = function(nodeKey) {
        var retVal = [];
        var tmpArr = this.executeLua(" \
                k, v = next(__rtiLookupTree['" + nodeKey + "'], nil) \
                return k, __rtiLookupTree.addNode(v)");
        retVal.push(tmpArr[1]);

        // Call next() again using as key the previous key (tmpArr[0])
        tmpArr = this.executeLua(" \
                k,v = next(__rtiLookupTree['" + nodeKey + "'], "  + tmpArr[0] + ") \
                return k, __rtiLookupTree.addNode(v)");
        retVal.push(tmpArr[0]);
        retVal.push(tmpArr[1]);
        return retVal;
    }
    // }}}
    // {{{ buildStructWithSingleMember
    // ----------------------------------------------------------------------------
    this.buildStructWithSingleMember = function(memberName, memberDef) {
        return this.executeLua(" \
                local memberDefLua = __rtiLookupTree['" + memberDef + "'] \
                local wrapper = xtypes.struct { MyStruct = {} } \
                setmetatable(wrapper, nil) \
                wrapper[1] = { " + memberName + " = memberDefLua } \
                return __rtiLookupTree.addNode(wrapper)")[0];
    }
    // }}}
    // {{{ dumpTree
    // ----------------------------------------------------------------------------
    // Return a string representation for debugging purposes only
    // Useful also to understand how to navigate a tree
    this.dumpTree = function(node) {
        var indentString = "  ";
        var out = "";
        var cache = {};
        var me = this;

        // The recursive core of the function.... concatenate the node representation into 'out'
        function _dumpDDSL(node, /* optional */ indent) {
            var indent = indent || 0;   // Default indentation is zero...
            var nodeKind = me.getKind(node);
            if (nodeKind == me.KIND_MODULE) {
                var name=me.getName(node);
                out += indentString.repeat(indent) + "module " + name;
                if (cache[name] == null) {
                    out += " {\n";
                    for (var i = 0; i < me.getArrayCount(node); ++i) {
                        _dumpDDSL(me.getArrayItem(node, i+1), indent+1);
                        out += "\n";
                    }
                    out += indentString.repeat(indent) + "}";
                    cache[name] = true;
                }

            } else if (nodeKind == me.KIND_STRUCT) {
                var name=me.getName(node);
                var scope = me.getBase(node);
                out += indentString.repeat(indent) + "struct " + name;
                if (scope) {
                    out += ": extends " + me.getName(scope);
                }
                if (cache[name] == null) {
                    out += " {\n";
                    for (var i = 0; i < me.getArrayCount(node); ++i) {
                        var prop = me.getArrayItem(node, i+1);
                        var propArrayInfo = me.getNext(prop);       // next() return name+def
                        var propName = propArrayInfo[0];
                        var propDef = propArrayInfo[1];

                        // NOTE: propDef is an array where the first item is the definition, the rest are annotations
                        var propType = me.getArrayItem(propDef, 1);
                        var propAnnCount = me.getArrayCount(propDef) - 1;

                        out += indentString.repeat(indent+1) + propName + ": ";
                        _dumpDDSL(propType);
                        if (propAnnCount > 0) {
                            out += ";   // ";
                            // Append annotations
                            for (var j = 0; j < propAnnCount; ++j) {
                                if (j > 0) out += ", ";
                                // it's j+2 because LUA starts from 1 and we skip the data type definition element
                                _dumpDDSL(me.getArrayItem(propDef, j+2));
                            }
                        }
                        out += ";\n";
                    }
                    out += indentString.repeat(indent) + "}";
                    cache[name] = true;
                }
            } else if (nodeKind == me.KIND_UNION) {
                var name=me.getName(node);
                out += indentString.repeat(indent) + "union " + name;
                if (cache[name] == null) {
                    var discriminator = me.getSwitch(node);
                    out += " (";
                    _dumpDDSL(discriminator);
                    out += ") {\n";
                    var caseCount = me.getArrayCount(node);
                    for (var i = 0; i < caseCount; ++i) {
                        var caseDef = me.getArrayItem(node, i+1);
                        // caseDef is a table containing two elements:
                        //  - caseDef[1] - Represent the value of the case - retrieve it with getArrayItem
                        //  - caseDef['fieldName'] = fieldDef - retrieve it with getStructPropertyName & getStructPropertyDefinition
                        //  Calling getUnionCase returns an array of the three elements: value, name, definition
                        var caseDefArr = me.getUnionCase(caseDef);
                        var caseValue = caseDefArr[0];
                        var caseName = caseDefArr[1];
                        var caseTypeDef = caseDefArr[2];

                        // Just like struct the caseTypeDef is an array with 1 element. The first element
                        // defines the type of this property, any subsequent elements represent the attribute nodes
                        var caseAnnCount = me.getArrayCount(caseTypeDef) - 1;
                        var caseTypeDef1 = me.getArrayItem(caseTypeDef, 1);

                        out += indentString.repeat(indent+1) + "case " + caseValue + ": ";
                        _dumpDDSL(caseTypeDef1);
                        out += " " + caseName;
                        if (caseAnnCount > 0) {
                            out += ";   // ";
                            // Append annotations
                            for (var j = 0; j < caseAnnCount; ++j) {
                                if (j > 0) out += ", ";
                                annDef = me.getArrayItem(caseTypeDef, j+2);
                                _dumpDDSL(annDef);
                            }
                        }
                        out += ";\n";
                    }
                    out += indentString.repeat(indent) + "}";
                    cache[name] = true;
                }

            } else if (nodeKind == me.KIND_ENUM) {
                var name=me.getName(node);
                out += indentString.repeat(indent) + "enum " + name;
                if (cache[name] == null) {
                    out += " {\n";
                    for (var i = 0; i < me.getArrayCount(node); ++i) {
                        var item = me.getArrayItem(node, i+1);
                        var enumInfo = me.getNext(item);
                        var enumName = enumInfo[0];
                        var enumValue = enumInfo[1];
                        out += indentString.repeat(indent+1) + enumName + " = " + enumValue + ";\n";
                    }
                    out += indentString.repeat(indent) + "};";
                    cache[name] = true;
                }

            } else if (nodeKind == me.KIND_TYPEDEF) {
                var name=me.getName(node);
                out += indentString.repeat(indent) + "typedef " + name;
                if (cache[name] == null) {
                    out += " = ";
                    var targetType = me.resolveTypedef(node);
                    _dumpDDSL(targetType);
                    out += ";";
                    cache[name] = true;
                }

            } else if (nodeKind == me.KIND_ANNOTATION) {
                out += indentString.repeat(indent) + me.toString(node);
            } else if (nodeKind == me.KIND_ATOM) {
                out += indentString.repeat(indent) + me.toString(node);
            } else if (nodeKind == me.KIND_CONST) {
                var constInfo = me.getConstValue(node);
                var constValue = constInfo[0];
                var constType = constInfo[1];
                out += indentString.repeat(indent) + "const " + me.getName(constType) + " " + me.toString(node) + " = " + constValue;

            } else {
                out += indentString.repeat(indent) + "** Error: unknown kind=" + nodeKind;
            }
        }

        // Invoke the dump with initial indent=0
        _dumpDDSL(node);
        return out;
    }
    // }}}

    // {{{ getLookupTableSize
    // ----------------------------------------------------------------------------
    this.getLookupTableSize = function() {
        return  this.executeLua("return __rtiLookupTreeSize")[0];
    }
    // }}}

    // {{{ cleanupLookupTree
    // ----------------------------------------------------------------------------
    this.cleanupLookupTree = function(rootNode) {
        this.executeLua(" \
                local rootNode = __rtiLookupTree['" + rootNode + "'] \
                local addNodeFn = __rtiLookupTree.addNode \
                __rtiLookupTreeSize = 0 \
                __rtiLookupTree = {} \
                __rtiLookupTree['addNode'] = addNodeFn \
                __rtiLookupTree.addNode(rootNode)");
        _theLuaVM.gc(2, 0);
    }
    // }}}
}   // End of RTIDDSL class


// ****************************************************************************
// RTIDDSL Helper
// ****************************************************************************
// {{{ RTIDDSLHelper_getTypeCodeByName
// ----------------------------------------------------------------------------
// Given the DDSL root node, search for the node describing the given data type
//
// \param ddsl      - The instance of DDSL
// \param rootNode  - The root node as returned by one of the DDSL builder
// \param item      - The name of the item to search
//
exports.RTIDDSLHelper_getTypeCodeByName = function (ddsl, rootNode, itemName) {
    // The root node is a module that can be indexed as array
    var ns = itemName.split("::");
    var currNode = rootNode;

    // Iterate through all the component of the name, i.e. "foo::bar::zoo"
    for (nsIdx = 0; nsIdx < ns.length; ++nsIdx) {
        var item = ns[nsIdx];       // "foo"
        // Search the node describing 'foo' inside currNode
        var numItems = ddsl.getArrayCount(currNode);
        for (var i = 0; i < numItems; ++i) {
            node = ddsl.getArrayItem(currNode, i+1);
            if (ddsl.toString(node) == item) {
                currNode = node;
                break;
            }
        }
        if (i == numItems) {
            // not found
            return null;
        }
    }
    return currNode;
}

// }}}
// {{{ RTIDDSLHelper_isPropertySequence
// ----------------------------------------------------------------------------
// Given the struct or union property definition object, returns true if it
// contains the 'sequence' attribute
//
// \param ddsl      - The instance of DDSL
// \param propDef   - The property definition node as returned by getNext over
//                    a union or struct property node.
// \return          - The boolean true if property is a sequence
//
exports.RTIDDSLHelper_isPropertySequence = function(ddsl, propDef) {
    var count = ddsl.getArrayCount(propDef);
    if (!count) {
        // no annotations
        return false;
    }
    for (var i = 1 /* First element of the array is the type */; i < count; ++i) {
        var annot = ddsl.getArrayItem(propDef, i+1);        // Arrays in LUA are zero-based
        if (ddsl.getAnnotationKind(annot) == ddsl.ANNOTATION_KIND_SEQUENCE) {
            return true;
        }
    }
    return false;
}
// }}}

// {{{ RTIDDSLHelper_getMemberDescriptionByName
// ----------------------------------------------------------------------------
// Given a node describing either a struct or a union, scans through the 
// members until it finds one with the given name and returns its 
// array node containing the type in pos 0 and the annotations
//
// \param node  the DDSL node identifying a struct or a union
// \param memberName the name of the member of the struct/union
//
// \return the DDSL array that can be iterated with getArrayCount/getArrayItem
//         to retrieve the type (in position 0) and annotations.
//         Returns null if the given member is not found or if the root node
//         is not a struct or union.
exports.RTIDDSLHelper_getMemberDescriptionByName = function(ddsl, node, memberName) {
    var nodeKind = ddsl.getKind(node);
    if (!nodeKind) {
        // ok let it go...
        return null;
    }
    if (nodeKind != ddsl.KIND_STRUCT && nodeKind != ddsl.KIND_UNION) {
        console.error("Invalid node kind: " + nodeKind + " - not a union or struct");
        return null;
    }
    var numMembers = ddsl.getArrayCount(node);
    if (!numMembers) {
        return null;
    }
    for (var i = 0; i < numMembers; ++i) {
        var member = ddsl.getArrayItem(node, i+1);
        var memberInfo = ddsl.getNext(member);
        if (memberInfo[0] == memberName) {
            return memberInfo[1];
        }
    }
    return null;
}

// }}}
// {{{ RTIDDSLHelper_resolveConst
// ----------------------------------------------------------------------------
exports.RTIDDSLHelper_resolveConst = function(ddsl, constNode) {
    if (ddsl.getKind(constNode) != ddsl.KIND_CONST) {
        console.error("Error: node is not a const: " + ddsl.getKind(constNode));
        return 0;
    }
    var constInfo = ddsl.getConstValue(constNode);
    var constValue = constInfo[0];
    if (typeof(constValue) == "string") {
        // recursively attempt to resolve it
        return exports.RTIDDSLHelper_resolveConst(ddsl, constValue);
    } 
    return constValue;
}

// }}}
// {{{ RTIDDSLHelper_resolveTypedef
// ----------------------------------------------------------------------------
// Takes a node describing a type, attempts to resolve it as typedef and returns the
// node of the resolved type.
//
// \param node  a DDSL node describing a type
// \returns     the node itself if it is not a typedef, otherwise recursively
//              resolve the typedef chain and return the end, non-typedef node
exports.RTIDDSLHelper_resolveTypedef = function(ddsl, node) {
    if (ddsl.getKind(node) != ddsl.KIND_TYPEDEF) {
        return node;
    }
    // Recursively resolve it
    return exports.RTIDDSLHelper_resolveTypedef(ddsl, ddsl.resolveTypedef(node));
}

// }}}
